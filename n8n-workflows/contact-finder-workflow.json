{
  "name": "Contact Finder - LinkedIn HR Contacts",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "148eaa2e-ca0f-46be-b4f2-647e48c28da7",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Receive Job Data",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "148eaa2e-ca0f-46be-b4f2-647e48c28da7"
    },
    {
      "parameters": {
        "jsCode": "// Extract the payload from webhook\nconst payload = $input.item.json.body;\n\n// Return structured data for the loop\nreturn {\n  json: {\n    userId: payload.userId,\n    userEmail: payload.userEmail,\n    contactsPerJob: payload.contactsPerJob,\n    jobs: payload.jobs\n  }\n};"
      },
      "id": "parse-webhook",
      "name": "Parse Webhook Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-jobs",
      "name": "Loop Jobs",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "url": "https://api.apify.com/v2/acts/caprolok~linkedin-employees-scraper/runs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "apifyApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "companyUrl",
              "value": "={{ $json.jobs[$json.$index].url }}"
            },
            {
              "name": "searchKeywords",
              "value": "={{ 'HR recruiter hiring talent acquisition people operations ' + $json.jobs[$json.$index].position }}"
            },
            {
              "name": "maxEmployees",
              "value": "50"
            },
            {
              "name": "proxy",
              "value": "{ \"useApifyProxy\": true }"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "apify-employees",
      "name": "Apify - Find Employees",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 300],
      "credentials": {
        "apifyApi": {
          "id": "apify-credentials",
          "name": "Apify API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Wait for Apify run to complete and get results\nconst runId = $input.item.json.data.id;\nconst apiToken = $env.APIFY_API_TOKEN;\n\nlet status = 'RUNNING';\nlet employees = [];\n\n// Poll until complete (max 5 minutes)\nfor (let i = 0; i < 60; i++) {\n  await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds\n  \n  const statusResponse = await fetch(`https://api.apify.com/v2/acts/caprolok~linkedin-employees-scraper/runs/${runId}?token=${apiToken}`);\n  const statusData = await statusResponse.json();\n  \n  status = statusData.data.status;\n  \n  if (status === 'SUCCEEDED') {\n    // Get dataset items\n    const datasetId = statusData.data.defaultDatasetId;\n    const dataResponse = await fetch(`https://api.apify.com/v2/datasets/${datasetId}/items?token=${apiToken}`);\n    employees = await dataResponse.json();\n    break;\n  } else if (status === 'FAILED' || status === 'ABORTED' || status === 'TIMED-OUT') {\n    throw new Error(`Apify run ${status}`);\n  }\n}\n\nif (status !== 'SUCCEEDED') {\n  throw new Error('Apify run timed out after 5 minutes');\n}\n\nreturn {\n  json: {\n    userId: $input.item.json.userId,\n    userEmail: $input.item.json.userEmail,\n    contactsPerJob: $input.item.json.contactsPerJob,\n    currentJob: $input.item.json.jobs[$input.item.json.$index],\n    employees: employees || []\n  }\n};"
      },
      "id": "wait-employees",
      "name": "Wait for Employee Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "jsCode": "// Filter employees to relevant contacts\nconst employees = $input.item.json.employees;\nconst job = $input.item.json.currentJob;\n\nif (!employees || employees.length === 0) {\n  return {\n    json: {\n      ...$input.item.json,\n      filteredEmployees: []\n    }\n  };\n}\n\n// Keywords for HR/recruiting roles\nconst hrKeywords = [\n  'recruiter', 'recruiting', 'talent acquisition', 'talent partner',\n  'hr', 'human resources', 'people operations', 'people partner',\n  'hiring', 'staffing', 'talent', 'sourcer', 'sourcing'\n];\n\n// Keywords for team/hiring manager roles related to the position\nconst positionKeywords = job.position.toLowerCase().split(' ');\n\n// Filter employees\nconst filtered = employees.filter(emp => {\n  const position = (emp.position || emp.headline || '').toLowerCase();\n  const name = (emp.name || emp.fullName || '').toLowerCase();\n  \n  // Include if HR/recruiting role\n  const isHR = hrKeywords.some(keyword => position.includes(keyword));\n  \n  // Include if position matches job title (potential hiring manager)\n  const isRelevantManager = positionKeywords.some(keyword => \n    keyword.length > 3 && position.includes(keyword)\n  );\n  \n  return isHR || isRelevantManager;\n});\n\nreturn {\n  json: {\n    ...$input.item.json,\n    filteredEmployees: filtered.slice(0, 20) // Limit to 20 for profile scraping\n  }\n};"
      },
      "id": "filter-employees",
      "name": "Filter Relevant Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "url": "https://api.apify.com/v2/acts/dev_fusion~linkedin-profile-scraper/runs",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "apifyApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "profileUrls",
              "value": "={{ $json.filteredEmployees.map(e => e.profileUrl || e.linkedinUrl).filter(Boolean) }}"
            },
            {
              "name": "proxy",
              "value": "{ \"useApifyProxy\": true }"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "apify-profiles",
      "name": "Apify - Get Full Profiles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 300],
      "credentials": {
        "apifyApi": {
          "id": "apify-credentials",
          "name": "Apify API"
        }
      },
      "executeOnce": false,
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Wait for Apify profile scraper to complete\nconst runId = $input.item.json.data.id;\nconst apiToken = $env.APIFY_API_TOKEN;\n\nlet status = 'RUNNING';\nlet profiles = [];\n\n// Poll until complete (max 5 minutes)\nfor (let i = 0; i < 60; i++) {\n  await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds\n  \n  const statusResponse = await fetch(`https://api.apify.com/v2/acts/dev_fusion~linkedin-profile-scraper/runs/${runId}?token=${apiToken}`);\n  const statusData = await statusResponse.json();\n  \n  status = statusData.data.status;\n  \n  if (status === 'SUCCEEDED') {\n    // Get dataset items\n    const datasetId = statusData.data.defaultDatasetId;\n    const dataResponse = await fetch(`https://api.apify.com/v2/datasets/${datasetId}/items?token=${apiToken}`);\n    profiles = await dataResponse.json();\n    break;\n  } else if (status === 'FAILED' || status === 'ABORTED' || status === 'TIMED-OUT') {\n    throw new Error(`Apify profile scraper ${status}`);\n  }\n}\n\nif (status !== 'SUCCEEDED') {\n  console.log('Profile scraper timed out, using basic employee data');\n  profiles = $input.item.json.filteredEmployees; // Fallback to basic data\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    profiles: profiles || []\n  }\n};"
      },
      "id": "wait-profiles",
      "name": "Wait for Profile Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "model": "gpt-4-mini",
        "messages": {
          "values": [
            {
              "content": "={{ \"You are a recruitment AI assistant. Rank these LinkedIn contacts by relevance for reaching out about a job application.\\n\\nJob Details:\\nPosition: \" + $json.currentJob.position + \"\\nCompany: \" + $json.currentJob.company + \"\\nLocation: \" + $json.currentJob.location + \"\\n\\nContacts to rank (JSON array): \" + JSON.stringify($json.profiles) + \"\\n\\nPlease rank each contact from 1-10 based on:\\n1. Role relevance (HR/recruiter = high, hiring manager = medium, other = low)\\n2. Seniority level (senior = higher priority)\\n3. Location match (same location as job = bonus points)\\n4. Recent activity/tenure\\n\\nReturn ONLY a JSON array with this structure:\\n[\\n  {\\n    \\\"name\\\": \\\"Full Name\\\",\\n    \\\"position\\\": \\\"Job Title\\\",\\n    \\\"email\\\": \\\"extracted email if available or null\\\",\\n    \\\"linkedin_url\\\": \\\"LinkedIn URL\\\",\\n    \\\"relevance_score\\\": 8,\\n    \\\"reasoning\\\": \\\"Brief explanation of score\\\"\\n  }\\n]\\n\\nSort by relevance_score descending.\" }}"
            }
          ]
        },
        "options": {}
      },
      "id": "openai-rank",
      "name": "OpenAI - Rank Contacts",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [1850, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and select top N contacts\nconst contactsPerJob = $input.item.json.contactsPerJob;\nconst job = $input.item.json.currentJob;\nconst userId = $input.item.json.userId;\n\nlet rankedContacts = [];\ntry {\n  const aiResponse = $input.item.json.choices[0].message.content;\n  // Extract JSON from response (sometimes AI adds markdown formatting)\n  const jsonMatch = aiResponse.match(/\\[.*\\]/s);\n  if (jsonMatch) {\n    rankedContacts = JSON.parse(jsonMatch[0]);\n  }\n} catch (error) {\n  console.error('Failed to parse AI response:', error);\n  // Fallback: use profiles as-is with basic scoring\n  rankedContacts = ($input.item.json.profiles || []).map((p, i) => ({\n    name: p.name || p.fullName,\n    position: p.position || p.headline,\n    email: p.email || null,\n    linkedin_url: p.profileUrl || p.linkedinUrl,\n    relevance_score: 10 - i,\n    reasoning: 'Auto-ranked by order'\n  }));\n}\n\n// Select top N contacts\nconst selectedContacts = rankedContacts.slice(0, contactsPerJob);\n\nreturn {\n  json: {\n    userId,\n    applicationId: job.applicationId,\n    jobId: job.jobId,\n    company: job.company,\n    position: job.position,\n    contacts: selectedContacts,\n    totalFound: rankedContacts.length,\n    totalSelected: selectedContacts.length\n  }\n};"
      },
      "id": "select-top-contacts",
      "name": "Select Top N Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_ANON_KEY }}"
            },
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ \"eq.\" + $json.userId }}"
            },
            {
              "name": "select",
              "value": "email,linkedin_url"
            }
          ]
        },
        "options": {}
      },
      "id": "check-duplicates",
      "name": "Check Existing Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 300],
      "credentials": {
        "supabaseApi": {
          "id": "supabase-credentials",
          "name": "Supabase API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter out duplicate contacts\nconst newContacts = $input.item.json.contacts;\nconst existingContacts = $input.all()[0].json || [];\n\nconst existingEmails = new Set(existingContacts.map(c => c.email?.toLowerCase()).filter(Boolean));\nconst existingLinkedIn = new Set(existingContacts.map(c => c.linkedin_url?.toLowerCase()).filter(Boolean));\n\nconst uniqueContacts = newContacts.filter(contact => {\n  const email = contact.email?.toLowerCase();\n  const linkedin = contact.linkedin_url?.toLowerCase();\n  \n  // Keep if not duplicate\n  if (email && existingEmails.has(email)) return false;\n  if (linkedin && existingLinkedIn.has(linkedin)) return false;\n  \n  return true;\n});\n\nreturn {\n  json: {\n    userId: $input.item.json.userId,\n    applicationId: $input.item.json.applicationId,\n    jobId: $input.item.json.jobId,\n    company: $input.item.json.company,\n    position: $input.item.json.position,\n    contacts: uniqueContacts,\n    duplicatesRemoved: newContacts.length - uniqueContacts.length,\n    totalUnique: uniqueContacts.length\n  }\n};"
      },
      "id": "remove-duplicates",
      "name": "Remove Duplicates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "mode": "url",
          "value": "https://docs.google.com/spreadsheets/d/YOUR_SHEET_ID_HERE"
        },
        "sheetName": {
          "__rl": true,
          "mode": "list",
          "value": "Contact Finder Logs"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $now.toISO() }}",
            "User ID": "={{ $json.userId }}",
            "Job": "={{ $json.position + ' at ' + $json.company }}",
            "Application ID": "={{ $json.applicationId }}",
            "Contacts Found": "={{ $json.totalUnique }}",
            "Duplicates Removed": "={{ $json.duplicatesRemoved }}",
            "Contact Names": "={{ $json.contacts.map(c => c.name).join(', ') }}"
          }
        },
        "options": {}
      },
      "id": "google-sheets-log",
      "name": "Log to Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [2650, 300],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "google-sheets-credentials",
          "name": "Google Sheets OAuth2"
        }
      },
      "executeOnce": false,
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "={{ $env.SIVIO_API_URL || 'https://sivio.vercel.app' }}/api/contacts/webhook",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ $json.userId }}"
            },
            {
              "name": "application_id",
              "value": "={{ $json.applicationId }}"
            },
            {
              "name": "contacts",
              "value": "={{ $json.contacts }}"
            }
          ]
        },
        "options": {}
      },
      "id": "push-to-supabase",
      "name": "Push Contacts to Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2850, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "sivio-webhook-auth",
          "name": "Sivio Webhook Auth"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $('Loop Jobs').item.json.done }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-loop-done",
      "name": "Check if Loop Done",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Contact finder completed for ' + $('Parse Webhook Data').item.json.jobs.length + ' jobs', processedJobs: $('Parse Webhook Data').item.json.jobs.length } }}"
      },
      "id": "webhook-response",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3250, 200]
    },
    {
      "parameters": {},
      "id": "continue-loop",
      "name": "Continue Loop",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3250, 400]
    }
  ],
  "connections": {
    "Webhook - Receive Job Data": {
      "main": [
        [
          {
            "node": "Parse Webhook Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Webhook Data": {
      "main": [
        [
          {
            "node": "Loop Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Jobs": {
      "main": [
        [
          {
            "node": "Apify - Find Employees",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apify - Find Employees": {
      "main": [
        [
          {
            "node": "Wait for Employee Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Employee Results": {
      "main": [
        [
          {
            "node": "Filter Relevant Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Relevant Contacts": {
      "main": [
        [
          {
            "node": "Apify - Get Full Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apify - Get Full Profiles": {
      "main": [
        [
          {
            "node": "Wait for Profile Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Profile Results": {
      "main": [
        [
          {
            "node": "OpenAI - Rank Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Rank Contacts": {
      "main": [
        [
          {
            "node": "Select Top N Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Top N Contacts": {
      "main": [
        [
          {
            "node": "Check Existing Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Existing Contacts": {
      "main": [
        [
          {
            "node": "Remove Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Duplicates": {
      "main": [
        [
          {
            "node": "Log to Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to Google Sheets": {
      "main": [
        [
          {
            "node": "Push Contacts to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Push Contacts to Supabase": {
      "main": [
        [
          {
            "node": "Check if Loop Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Loop Done": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Loop": {
      "main": [
        [
          {
            "node": "Loop Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-16T00:00:00.000Z",
  "versionId": "1"
}
