{
  "name": "Contact Finder - Optimized for Profit",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "148eaa2e-ca0f-46be-b4f2-647e48c28da7",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "148eaa2e-ca0f-46be-b4f2-647e48c28da7"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"message\": \"Contact finder started\", \"jobs\": $json.body.jobs.length } }}"
      },
      "id": "respond-immediately",
      "name": "Respond Immediately",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [440, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "userId",
              "name": "userId",
              "value": "={{ $json.body.userId }}",
              "type": "string"
            },
            {
              "id": "userEmail",
              "name": "userEmail",
              "value": "={{ $json.body.userEmail }}",
              "type": "string"
            },
            {
              "id": "contactsPerJob",
              "name": "contactsPerJob",
              "value": "={{ $json.body.contactsPerJob }}",
              "type": "number"
            },
            {
              "id": "jobs",
              "name": "jobs",
              "value": "={{ $json.body.jobs }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-payload",
      "name": "Extract Payload",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [640, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-jobs",
      "name": "Loop Jobs",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [840, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "currentJob",
              "name": "currentJob",
              "value": "={{ $('Extract Payload').item.json.jobs[$('Loop Jobs').context.currentRunIndex] }}",
              "type": "object"
            },
            {
              "id": "companyUrl",
              "name": "companyUrl",
              "value": "={{ $('Extract Payload').item.json.jobs[$('Loop Jobs').context.currentRunIndex].url }}",
              "type": "string"
            },
            {
              "id": "searchKeywords",
              "name": "searchKeywords",
              "value": "={{ \"recruiter talent acquisition HR hiring \" + $('Extract Payload').item.json.jobs[$('Loop Jobs').context.currentRunIndex].position.split(' ').filter(w => w.length > 3).join(' ') }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "prepare-apify-input",
      "name": "Prepare Apify Input",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1040, 300]
    },
    {
      "parameters": {
        "actor": "apify/linkedin-company-employees",
        "waitForFinish": true,
        "input": {
          "companyUrl": "={{ $json.companyUrl }}",
          "searchKeywords": "={{ $json.searchKeywords }}",
          "maxItems": 15
        },
        "options": {}
      },
      "id": "apify-find-employees",
      "name": "Apify - Find Employees",
      "type": "@apify/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [1240, 300],
      "credentials": {
        "apifyApi": {
          "id": "{{APIFY_CREDENTIAL_ID}}",
          "name": "Apify account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter to HR/recruiters + team-relevant contacts\nconst employees = $input.all();\nconst currentJob = $('Prepare Apify Input').item.json.currentJob;\nconst contactsPerJob = $('Extract Payload').item.json.contactsPerJob;\n\n// HR/recruiting keywords (HIGH PRIORITY)\nconst hrKeywords = [\n  'recruit', 'talent acquisition', 'talent partner', 'talent',\n  'hr', 'human resources', 'people operations', 'people partner',\n  'hiring manager', 'hiring', 'staffing', 'sourcer', 'sourcing'\n];\n\n// Extract key skills from job position for team matching\nconst positionWords = currentJob.position.toLowerCase().split(' ');\nconst teamKeywords = positionWords.filter(w => w.length > 3);\n\n// Score each employee\nconst scoredEmployees = employees.map(item => {\n  const emp = item.json;\n  const headline = (emp.headline || emp.position || '').toLowerCase();\n  const name = (emp.name || emp.fullName || '').toLowerCase();\n  \n  let score = 0;\n  let role = 'other';\n  \n  // Check if HR/recruiting (HIGHEST PRIORITY)\n  const isHR = hrKeywords.some(keyword => headline.includes(keyword));\n  if (isHR) {\n    score = 100;\n    role = 'hr';\n  }\n  \n  // Check if team member (relevant to position)\n  const isTeamMember = teamKeywords.some(keyword => headline.includes(keyword));\n  if (isTeamMember && !isHR) {\n    score = 70;\n    role = 'team';\n  }\n  \n  // Check seniority\n  if (headline.includes('senior') || headline.includes('lead') || headline.includes('director') || headline.includes('head')) {\n    score += 20;\n  }\n  if (headline.includes('manager')) {\n    score += 15;\n  }\n  \n  // Location bonus\n  if (emp.location && currentJob.location) {\n    const empLocation = emp.location.toLowerCase();\n    const jobLocation = currentJob.location.toLowerCase();\n    if (empLocation.includes(jobLocation) || jobLocation.includes(empLocation)) {\n      score += 10;\n    }\n  }\n  \n  return {\n    ...emp,\n    score,\n    role\n  };\n});\n\n// Sort by score (highest first)\nscoredEmployees.sort((a, b) => b.score - a.score);\n\n// Filter: Keep HR (score 100+) and top team members (score 70+)\nconst filtered = scoredEmployees.filter(e => e.score >= 60);\n\n// Limit to contactsPerJob (user's choice, max 10)\nconst topContacts = filtered.slice(0, Math.min(contactsPerJob, 10));\n\nif (topContacts.length === 0) {\n  return [{\n    json: {\n      userId: $('Extract Payload').item.json.userId,\n      userEmail: $('Extract Payload').item.json.userEmail,\n      currentJob: currentJob,\n      employees: [],\n      message: 'No relevant contacts found'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    userId: $('Extract Payload').item.json.userId,\n    userEmail: $('Extract Payload').item.json.userEmail,\n    currentJob: currentJob,\n    employees: topContacts\n  }\n}];"
      },
      "id": "filter-and-rank",
      "name": "Filter & Rank Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "aiContext",
              "name": "aiContext",
              "value": "={{ \"Rank these contacts for outreach about:\\n\\nPosition: \" + $json.currentJob.position + \"\\nCompany: \" + $json.currentJob.company + \"\\nLocation: \" + $json.currentJob.location + \"\\n\\nContacts (already pre-filtered and scored):\\n\" + JSON.stringify($json.employees.map((e, i) => ({\n  id: i,\n  name: e.fullName || e.name,\n  headline: e.headline || e.position,\n  location: e.location,\n  preScore: e.score,\n  role: e.role\n})), null, 2) + \"\\n\\nReturn ONLY valid JSON array (no markdown, no code blocks):\\n[{\\\"id\\\": 0, \\\"finalScore\\\": 95, \\\"reasoning\\\": \\\"Brief why they're good to contact\\\"}]\\n\\nConsider: 1) HR/recruiter role (best), 2) Team manager role (good), 3) Seniority, 4) Location match. Return all contacts ranked.\" }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "prepare-ai-prompt",
      "name": "Prepare AI Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1640, 300]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "messages": {
          "values": [
            {
              "content": "={{ $json.aiContext }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2
        }
      },
      "id": "openai-rank",
      "name": "OpenAI - Final Ranking",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [1840, 300],
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and create final contacts\nconst aiMessage = $input.item.json.message || $input.item.json;\nconst aiResponse = aiMessage.content || JSON.stringify(aiMessage);\nconst currentJob = $('Filter & Rank Contacts').item.json.currentJob;\nconst employees = $('Filter & Rank Contacts').item.json.employees || [];\nconst userId = $('Extract Payload').item.json.userId;\n\nlet rankedContacts = [];\ntry {\n  // Extract JSON from AI response\n  const jsonMatch = aiResponse.match(/\\[.*\\]/s);\n  if (jsonMatch) {\n    rankedContacts = JSON.parse(jsonMatch[0]);\n  } else {\n    // Fallback: use pre-scored order\n    rankedContacts = employees.map((e, i) => ({\n      id: i,\n      finalScore: e.score,\n      reasoning: `${e.role === 'hr' ? 'HR/Recruiter' : 'Team member'} - pre-scored ${e.score}`\n    }));\n  }\n} catch (e) {\n  console.log('AI parse failed, using fallback');\n  rankedContacts = employees.map((e, i) => ({\n    id: i,\n    finalScore: e.score,\n    reasoning: `Auto-ranked: ${e.role}`\n  }));\n}\n\n// Map to final contact format\nconst finalContacts = rankedContacts.map(ranked => {\n  const employee = employees[ranked.id];\n  if (!employee) return null;\n  \n  return {\n    name: employee.fullName || employee.name || 'Unknown',\n    position: employee.headline || employee.position || '',\n    email: employee.email || null,\n    company: currentJob.company,\n    linkedin_url: employee.profileUrl || employee.url || null,\n    verified: false,\n    relevance_score: ranked.finalScore || employee.score || 50,\n    reasoning: ranked.reasoning || `${employee.role} role`,\n    source: 'linkedin_apify',\n    role_type: employee.role || 'unknown'\n  };\n}).filter(Boolean);\n\nreturn {\n  json: {\n    userId,\n    applicationId: currentJob.applicationId,\n    jobId: currentJob.jobId,\n    company: currentJob.company,\n    position: currentJob.position,\n    contacts: finalContacts\n  }\n};"
      },
      "id": "create-final-contacts",
      "name": "Create Final Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2040, 300]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "contacts",
        "returnAll": false,
        "limit": 1000,
        "options": {
          "queryString": "=user_id=eq.{{ $json.userId }}"
        }
      },
      "id": "check-duplicates",
      "name": "Check Duplicates (Supabase)",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2240, 300],
      "credentials": {
        "supabaseApi": {
          "id": "{{SUPABASE_CREDENTIAL_ID}}",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Remove duplicates based on existing contacts\nconst newContacts = $('Create Final Contacts').item.json.contacts;\nconst existingContacts = $input.all().map(item => item.json);\n\nconst existingEmails = new Set(\n  existingContacts\n    .map(c => c.email?.toLowerCase())\n    .filter(Boolean)\n);\n\nconst existingLinkedIn = new Set(\n  existingContacts\n    .map(c => c.linkedin_url?.toLowerCase())\n    .filter(Boolean)\n);\n\nconst uniqueContacts = newContacts.filter(contact => {\n  const email = contact.email?.toLowerCase();\n  const linkedin = contact.linkedin_url?.toLowerCase();\n  \n  // Skip if email exists\n  if (email && existingEmails.has(email)) {\n    console.log(`Skipping duplicate email: ${email}`);\n    return false;\n  }\n  \n  // Skip if LinkedIn URL exists\n  if (linkedin && existingLinkedIn.has(linkedin)) {\n    console.log(`Skipping duplicate LinkedIn: ${linkedin}`);\n    return false;\n  }\n  \n  return true;\n});\n\nconst duplicatesRemoved = newContacts.length - uniqueContacts.length;\n\nreturn {\n  json: {\n    userId: $('Create Final Contacts').item.json.userId,\n    applicationId: $('Create Final Contacts').item.json.applicationId,\n    jobId: $('Create Final Contacts').item.json.jobId,\n    company: $('Create Final Contacts').item.json.company,\n    position: $('Create Final Contacts').item.json.position,\n    contacts: uniqueContacts,\n    totalFound: newContacts.length,\n    duplicatesRemoved: duplicatesRemoved,\n    uniqueCount: uniqueContacts.length\n  }\n};"
      },
      "id": "remove-duplicates",
      "name": "Remove Duplicates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "sheetName": {
          "__rl": true,
          "mode": "list",
          "value": "Contact Finder Logs"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $now.toISO() }}",
            "User ID": "={{ $json.userId }}",
            "Job": "={{ $json.position + ' at ' + $json.company }}",
            "Application ID": "={{ $json.applicationId }}",
            "Total Found": "={{ $json.totalFound }}",
            "Unique Added": "={{ $json.uniqueCount }}",
            "Duplicates Skipped": "={{ $json.duplicatesRemoved }}",
            "Contact Names": "={{ $json.contacts.map(c => c.name + ' (' + c.role_type + ')').join(', ') }}"
          }
        },
        "options": {}
      },
      "id": "log-to-sheets",
      "name": "Log to Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2640, 300],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "https://sivio.vercel.app/api/contacts/webhook",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-webhook-secret",
              "value": "wh_sec_contact_finder_n8n_2025_prod_v1_secure_token_xK9mP3nQ7yR2vL8cF4jH6tS1wN5bG0d"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"user_id\": $json.userId,\n  \"application_id\": $json.applicationId,\n  \"contacts\": $json.contacts\n} }}",
        "options": {}
      },
      "id": "push-to-sivio",
      "name": "Push to Sivio",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2840, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "loop-done-check",
              "leftValue": "={{ $('Loop Jobs').context.noItemsLeft }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-loop-done",
      "name": "Loop Done?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3040, 300]
    },
    {
      "parameters": {},
      "id": "workflow-complete",
      "name": "Complete",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3240, 200]
    },
    {
      "parameters": {},
      "id": "continue-loop",
      "name": "Next Job",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3240, 400]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Respond Immediately",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Immediately": {
      "main": [
        [
          {
            "node": "Extract Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload": {
      "main": [
        [
          {
            "node": "Loop Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Jobs": {
      "main": [
        [
          {
            "node": "Prepare Apify Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Apify Input": {
      "main": [
        [
          {
            "node": "Apify - Find Employees",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apify - Find Employees": {
      "main": [
        [
          {
            "node": "Filter & Rank Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter & Rank Contacts": {
      "main": [
        [
          {
            "node": "Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Prompt": {
      "main": [
        [
          {
            "node": "OpenAI - Final Ranking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Final Ranking": {
      "main": [
        [
          {
            "node": "Create Final Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Final Contacts": {
      "main": [
        [
          {
            "node": "Check Duplicates (Supabase)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicates (Supabase)": {
      "main": [
        [
          {
            "node": "Remove Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Duplicates": {
      "main": [
        [
          {
            "node": "Log to Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to Google Sheets": {
      "main": [
        [
          {
            "node": "Push to Sivio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Push to Sivio": {
      "main": [
        [
          {
            "node": "Loop Done?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Done?": {
      "main": [
        [
          {
            "node": "Complete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Next Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Next Job": {
      "main": [
        [
          {
            "node": "Loop Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-16T00:00:00.000Z",
  "versionId": "4"
}
